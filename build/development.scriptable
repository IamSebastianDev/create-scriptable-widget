{"icon":{"color":"blue","glyph":"screen"},"name":"development","script":"/** @format */\n\n// Variables used by Scriptable.\n// These must be at the very top of the file. Do not edit.\n// icon-color: blue ; icon-glyph: screen ;\n\n/**\n *\tThis is the slug used for developing the Scriptable widget. The code is copied to a fresh scriptable widget and will\n *\tsubsequently fetch the freshly build code on every refresh, significantly simplifying the process.\n */\n\nconst FM = FileManager.local();\nconst slug = {\n\tname: 'development',\n\tserver: 'http://Sebastians-MBP.fritz.box:31415/widget',\n\targuments: false,\n};\n\n(async () => {\n\t/**\n\t * Get the project root by taking the filename of the module and replacing the file with nothing,\n\t * leaving the root path.\n\t */\n\n\tconst moduleName = module.filename;\n\tconst __root = moduleName.replace(FM.fileName(moduleName, true), '');\n\n\t/**\n\t * Check if a directory with the current namespace already exsists. If the directory exists, delete it and it's\n\t * contents and then recreate it. If a file exists at the location the directory should be created, throw an error\n\t */\n\n\tconst targetDirName = FM.joinPath(__root, slug.name);\n\tconst targetFileName = FM.joinPath(targetDirName, slug.name + '.dev.js');\n\n\tif (FM.fileExists(targetDirName) && FM.isDirectory(targetDirName)) {\n\t\tFM.remove(targetDirName);\n\t} else {\n\t\tthrow new Error(\n\t\t\t`CSW: ${targetDirName} already exists, but it not a directory. Make sure there are no conflicts or remove the file/directory manually.`\n\t\t);\n\t}\n\tFM.createDirectory(targetDirName);\n\n\t/**\n\t * Request the file from the development API and write it to the directory\n\t * with the filename created above. In development mode, the file is always overwritten\n\t * to gurantee a fresh file on every refresh.\n\t */\n\n\ttry {\n\t\tconst req = new Request(slug.server);\n\t\tconst res = await req.load();\n\t\t\n\t\tFM.write(targetFileName, res);\n\t} catch(e) {\n\t\t console.error(\"CSW: Could not establish connection to the development server.\")\n\t}\n\n\t/**\n\t * Impprt and execute the bundle from the created file. The method is wrapped in a try catch so\n\t * that errors occuring in the file can still be caught by scriptable. This is important as each\n\t * module is executed in it's own module scope, and scriptable will NOT receive errors thrown in the\n\t * imported module.\n\t */\n\n\tconst bundle = importModule(targetFileName);\n\n\ttry {\n\t\tconst widget = await bundle({ widgetParameter: slug.arguments });\n\t\t!config.runsInWidget && (await widget.presentSmall());\n\n\t\tScript.setWidget(widget);\n\t\tScript.complete();\n\t} catch (e) {\n\t\tconsole.error(e);\n\t}\n})();\n"}