{"version":3,"file":"index.js","sources":["../src/lib/fetch.mjs","../src/lib/remote.mjs"],"sourcesContent":["/** @format */\n\nconst handleOnRedirect = (method = 'follow', request) => {\n\tswitch (method) {\n\t\tcase 'follow':\n\t\t\treturn request;\n\t\tcase 'error':\n\t\t\tthrow new Error(\n\t\t\t\t`CWS-Fetch: The request was redirected. Aborting with error.`\n\t\t\t);\n\t\tcase 'manual':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\n\t\t\t\t`CWS-Fetch: '${method} 'is not recognized as a valid redirect methid. Set method to 'follow', 'error' or 'manual'`\n\t\t\t);\n\t}\n};\n\n/**\n * A lightweight custom wrapper for the scriptable Request() method to more resemble the native fetch api.\n * Due to the limitations of the Request method, not all features are implemented.\n *\n * @param { string } resource the url the request should fetch from.\n * @param { {} } init - An object containing any custom settings that you want to apply to the request. The possible\n * options are:\n *  - method: The HTTP Method to use. Is 'GET' by default.\n *  - headers: Any headers to send with the request.\n *  - body: The request body.\n *  - redirect: What to do on redirect. Possible values are 'follow' to allow redirects, 'error' to abort with an error\n * and 'manual' to handle the redirect manually.\n *  - allowInsecureRequest: By default Scriptable will attempt to reject requests that are deemed insecure. Set to true\n * to overwrite.\n */\n\nexport const fetch = async (resource, init) =>\n\tnew Promise(async (resolve) => {\n\t\tconst req = new Request(resource);\n\t\treq.method = init.method || 'GET';\n\t\treq.headers = init.headers;\n\t\treq.body = init.body;\n\t\treq.redirect = handleOnRedirect.bind(null, init.redirect);\n\t\treq.allowInsecureRequest = init.allowInsecureRequest || false;\n\n\t\tconst response = await req.load();\n\t\tresolve(response);\n\t});\n","/** @format */\n\nimport { fetch } from './fetch.mjs';\n\nconst dispatch = async (receive) => {\n\t// check if the global hostname constant is set and return if it does not exist.\n\t// in theory, setting a own constant can be used to communicate with a custom server\n\t// if desired by the consumer.\n\n\tif (!HOSTNAME || typeof HOSTNAME !== 'string') {\n\t\treturn;\n\t}\n\n\tconst { type, data } = receive;\n\tif (data.optionalParams.length === 0) {\n\t\tdelete data.optionalParams;\n\t}\n\n\tconst payload = { type, data: !data.optionalParams ? data.message : data };\n\tconst address = 'http://' + HOSTNAME + '/socket';\n\tawait fetch(address, {\n\t\tmethod: 'POST',\n\t\theaders: { 'Content-type': 'application/json' },\n\t\tbody: JSON.stringify(payload),\n\t});\n};\n\nexport const remote = {\n\t/**\n\t * Method will log a message to the console, and dispatch the message to the development application. This method\n\t * will only work in the development enviroment. All passed values are passed through to the console.log method to\n\t * be logged by scriptable.\n\t *\n\t * @param {*} message primary message\n\t * @param  {...any} optionalParams substitution values\n\t */\n\n\tlog: (message, ...optionalParams) => {\n\t\tconsole.log(message, ...optionalParams);\n\t\tdispatch({ type: 'log', data: { message, optionalParams } });\n\t},\n\n\t/**\n\t * Method will log a warning to the console, and dispatch the warning to the development application. This method\n\t * will only work in the development enviroment. All passed values are passed through to the console.log method to\n\t * be logged by scriptable.\n\t *\n\t * @param {*} message primary message\n\t * @param  {...any} optionalParams substitution values\n\t */\n\n\twarn: (message, ...optionalParams) => {\n\t\tconsole.warn(message, ...optionalParams);\n\t\tdispatch({ type: 'warn', data: { message, optionalParams } });\n\t},\n\n\t/**\n\t * Method will log a error to the console, and dispatch the error to the development application. This method\n\t * will only work in the development enviroment. All passed values are passed through to the console.log method to\n\t * be logged by scriptable.\n\t *\n\t * @param {*} message primary message\n\t * @param  {...any} optionalParams substitution values\n\t */\n\n\terror: (message, ...optionalParams) => {\n\t\tconsole.error(message, ...optionalParams);\n\t\tdispatch({ type: 'error', data: { message, optionalParams } });\n\t},\n};\n"],"names":["handleOnRedirect","method","request","Error","fetch","async","resource","init","Promise","resolve","req","Request","headers","body","redirect","bind","allowInsecureRequest","load","dispatch","receive","HOSTNAME","type","data","optionalParams","length","payload","message","address","JSON","stringify","remote","log","console","warn","error"],"mappings":"oEAEA,MAAMA,EAAmB,CAACC,EAAS,SAAUC,KAC5C,OAAQD,GACP,IAAK,SACJ,OAAOC,EACR,IAAK,QACJ,MAAM,IAAIC,MACT,+DAEF,IAAK,SACJ,MACD,QACC,MAAM,IAAIA,MACT,eAAeF,kGAqBNG,EAAQC,MAAOC,EAAUC,IACrC,IAAIC,SAAQH,MAAOI,IAClB,MAAMC,EAAM,IAAIC,QAAQL,GACxBI,EAAIT,OAASM,EAAKN,QAAU,MAC5BS,EAAIE,QAAUL,EAAKK,QACnBF,EAAIG,KAAON,EAAKM,KAChBH,EAAII,SAAWd,EAAiBe,KAAK,KAAMR,EAAKO,UAChDJ,EAAIM,qBAAuBT,EAAKS,uBAAwB,EAGxDP,QADuBC,EAAIO,WCxCvBC,EAAWb,MAAOc,IAKvB,IAAKC,UAAgC,iBAAbA,SACvB,OAGD,MAAMC,KAAEA,EAAIC,KAAEA,GAASH,EACY,IAA/BG,EAAKC,eAAeC,eAChBF,EAAKC,eAGb,MAAME,EAAU,CAAEJ,KAAAA,EAAMC,KAAOA,EAAKC,eAAgCD,EAAfA,EAAKI,SACpDC,EAAU,UAAYP,SAAW,gBACjChB,EAAMuB,EAAS,CACpB1B,OAAQ,OACRW,QAAS,CAAE,eAAgB,oBAC3BC,KAAMe,KAAKC,UAAUJ,MAIVK,EAAS,CAUrBC,IAAK,CAACL,KAAYH,KACjBS,QAAQD,IAAIL,KAAYH,GACxBL,EAAS,CAAEG,KAAM,MAAOC,KAAM,CAAEI,QAAAA,EAASH,eAAAA,MAY1CU,KAAM,CAACP,KAAYH,KAClBS,QAAQC,KAAKP,KAAYH,GACzBL,EAAS,CAAEG,KAAM,OAAQC,KAAM,CAAEI,QAAAA,EAASH,eAAAA,MAY3CW,MAAO,CAACR,KAAYH,KACnBS,QAAQE,MAAMR,KAAYH,GAC1BL,EAAS,CAAEG,KAAM,QAASC,KAAM,CAAEI,QAAAA,EAASH,eAAAA"}